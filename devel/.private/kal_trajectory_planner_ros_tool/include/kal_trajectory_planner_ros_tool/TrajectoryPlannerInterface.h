// *********************************************************
//
// File autogenerated for the kal_trajectory_planner_ros_tool package
// by the rosinterface_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <stdlib.h>
#include <string>
#include <limits>
#include <memory>
#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosinterface_handler/console_bridge_compatibility.hpp>
#include <rosinterface_handler/utilities.hpp>
#ifdef MESSAGE_FILTERS_FOUND
#include <message_filters/subscriber.h>
#include <nav_msgs/Path.h>
#else
#error message_filters was not found during compilation. Please recompile with message_filters.
#endif
#ifndef DIAGNOSTIC_UPDATER_FOUND

#endif
#ifdef DYNAMIC_RECONFIGURE_FOUND
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wparentheses"
#include <kal_trajectory_planner_ros_tool/TrajectoryPlannerConfig.h>
#pragma GCC diagnostic pop
#else
struct TrajectoryPlannerConfig{};
#endif

namespace kal_trajectory_planner_ros_tool {

/// \brief Parameter struct generated by rosinterface_handler
struct TrajectoryPlannerInterface {

  using Config = TrajectoryPlannerConfig;
#ifdef MESSAGE_FILTERS_FOUND
  template<typename T>
  using Subscriber = message_filters::Subscriber<T>;
  template<typename T>
  using SubscriberPtr = std::shared_ptr<Subscriber<T>>;
#endif
#ifdef IF_HANDLER_DIAGNOSTICS_INCLUDED
  template<typename T, typename BaseT = message_filters::Subscriber<T>>
  using DiagSubscriber = rosinterface_handler::DiagnosedSubscriber<T, BaseT>;
  template<typename T, typename BaseT = message_filters::Subscriber<T>>
  using DiagSubscriberPtr = std::shared_ptr<DiagSubscriber<T, BaseT>>;
  template<typename T>
  using DiagPublisher = rosinterface_handler::DiagnosedPublisher<T>;
#endif

  TrajectoryPlannerInterface(const ros::NodeHandle& private_node_handle)
  : globalNamespace_{"/"},
    publicNamespace_{rosinterface_handler::getParentNamespace(private_node_handle) + "/"},
    privateNamespace_{private_node_handle.getNamespace() + "/"},
    nodeName_{rosinterface_handler::getNodeName(private_node_handle)},
    privateNodeHandle_{private_node_handle},
    path_subscriber{std::make_shared<Subscriber<nav_msgs::Path>>()} {}

  /// \brief Get values from parameter server
  ///
  /// Will fail if a value can not be found and no default value is given.
  void fromParamServer(){
    bool success = true;
    success &= rosinterface_handler::getParam(privateNamespace_ + "verbosity", verbosity, std::string{"info"});
    rosinterface_handler::setLoggerLevel(privateNodeHandle_, "verbosity", nodeNameWithNamespace());
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_debug");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_info");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_warning");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_error");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_fatal");
    success &= rosinterface_handler::getParam(privateNamespace_ + "map_frame", map_frame);
    success &= rosinterface_handler::getParam(privateNamespace_ + "timer_rate", timer_rate);
    success &= rosinterface_handler::getParam(privateNamespace_ + "vehicle_frame", vehicle_frame);
    success &= rosinterface_handler::getParam(privateNamespace_ + "desired_speed", desired_speed);
    success &= rosinterface_handler::getParam(privateNamespace_ + "polynomial_degree", polynomial_degree);
    success &= rosinterface_handler::getParam(privateNamespace_ + "trajectory_length", trajectory_length);
    success &= rosinterface_handler::getParam(privateNamespace_ + "trajectory_num_of_points", trajectory_num_of_points);
    success &= rosinterface_handler::getParam(privateNamespace_ + "path_subscriber_topic", path_subscriber_topic);
    success &= rosinterface_handler::getParam(privateNamespace_ + "path_subscriber_queue_size", path_subscriber_queue_size, int{5});
    success &= rosinterface_handler::getParam(privateNamespace_ + "trajectory_publisher_topic", trajectory_publisher_topic);
    success &= rosinterface_handler::getParam(privateNamespace_ + "trajectory_publisher_queue_size", trajectory_publisher_queue_size, int{5});

    path_subscriber->subscribe(privateNodeHandle_, rosinterface_handler::getTopic(privateNamespace_, path_subscriber_topic), uint32_t(path_subscriber_queue_size), ros::TransportHints().tcpNoDelay());
    trajectory_publisher = privateNodeHandle_.advertise<nav_msgs::Path>(rosinterface_handler::getTopic(privateNamespace_, trajectory_publisher_topic), trajectory_publisher_queue_size);

    rosinterface_handler::testMin<double>(privateNamespace_ + "timer_rate", timer_rate, 0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "timer_rate", timer_rate, 20);
    rosinterface_handler::testMin<double>(privateNamespace_ + "desired_speed", desired_speed, 0.5);
    rosinterface_handler::testMax<double>(privateNamespace_ + "desired_speed", desired_speed, 20.0);
    rosinterface_handler::testMin<int>(privateNamespace_ + "polynomial_degree", polynomial_degree, 0);
    rosinterface_handler::testMax<int>(privateNamespace_ + "polynomial_degree", polynomial_degree, 10);
    rosinterface_handler::testMin<double>(privateNamespace_ + "trajectory_length", trajectory_length, 0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "trajectory_length", trajectory_length, 10);
    rosinterface_handler::testMin<int>(privateNamespace_ + "trajectory_num_of_points", trajectory_num_of_points, 2);
    rosinterface_handler::testMax<int>(privateNamespace_ + "trajectory_num_of_points", trajectory_num_of_points, 100);
    rosinterface_handler::testMin<int>(privateNamespace_ + "path_subscriber_queue_size", path_subscriber_queue_size, 0);
    rosinterface_handler::testMin<int>(privateNamespace_ + "trajectory_publisher_queue_size", trajectory_publisher_queue_size, 0);
    if(!success){
      missingParamsWarning();
      rosinterface_handler::exit("RosinterfaceHandler: GetParam could net retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
  }

  /// \brief Set parameters on ROS parameter server.
  void toParamServer(){
    rosinterface_handler::setParam(privateNamespace_ + "verbosity",verbosity);
    rosinterface_handler::setParam(privateNamespace_ + "map_frame",map_frame);
    rosinterface_handler::setParam(privateNamespace_ + "timer_rate",timer_rate);
    rosinterface_handler::setParam(privateNamespace_ + "vehicle_frame",vehicle_frame);
    rosinterface_handler::setParam(privateNamespace_ + "desired_speed",desired_speed);
    rosinterface_handler::setParam(privateNamespace_ + "polynomial_degree",polynomial_degree);
    rosinterface_handler::setParam(privateNamespace_ + "trajectory_length",trajectory_length);
    rosinterface_handler::setParam(privateNamespace_ + "trajectory_num_of_points",trajectory_num_of_points);
    rosinterface_handler::setParam(privateNamespace_ + "path_subscriber_topic",path_subscriber_topic);
    rosinterface_handler::setParam(privateNamespace_ + "path_subscriber_queue_size",path_subscriber_queue_size);
    rosinterface_handler::setParam(privateNamespace_ + "trajectory_publisher_topic",trajectory_publisher_topic);
    rosinterface_handler::setParam(privateNamespace_ + "trajectory_publisher_queue_size",trajectory_publisher_queue_size);
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0){
#ifdef DYNAMIC_RECONFIGURE_FOUND

    if(config.verbosity != this->verbosity) {
        rosinterface_handler::setParam(privateNamespace_ + "verbosity", config.verbosity);
        rosinterface_handler::setLoggerLevel(privateNodeHandle_, "verbosity", nodeNameWithNamespace());
    }
    verbosity = config.verbosity;
    desired_speed = config.desired_speed;
    polynomial_degree = config.polynomial_degree;
    trajectory_length = config.trajectory_length;
    trajectory_num_of_points = config.trajectory_num_of_points;
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  rosinterface_handler::exit("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const TrajectoryPlannerInterface& p)
  {
    os << "[" << p.nodeNameWithNamespace() << "]\nNode " << p.nodeNameWithNamespace() << " has the following parameters:\n"
      << "	" << p.privateNamespace_ << "verbosity:" << p.verbosity << "\n"
      << "	" << p.privateNamespace_ << "verbosity_debug:" << p.verbosity_debug << "\n"
      << "	" << p.privateNamespace_ << "verbosity_info:" << p.verbosity_info << "\n"
      << "	" << p.privateNamespace_ << "verbosity_warning:" << p.verbosity_warning << "\n"
      << "	" << p.privateNamespace_ << "verbosity_error:" << p.verbosity_error << "\n"
      << "	" << p.privateNamespace_ << "verbosity_fatal:" << p.verbosity_fatal << "\n"
      << "	" << p.privateNamespace_ << "map_frame:" << p.map_frame << "\n"
      << "	" << p.privateNamespace_ << "timer_rate:" << p.timer_rate << "\n"
      << "	" << p.privateNamespace_ << "vehicle_frame:" << p.vehicle_frame << "\n"
      << "	" << p.privateNamespace_ << "desired_speed:" << p.desired_speed << "\n"
      << "	" << p.privateNamespace_ << "polynomial_degree:" << p.polynomial_degree << "\n"
      << "	" << p.privateNamespace_ << "trajectory_length:" << p.trajectory_length << "\n"
      << "	" << p.privateNamespace_ << "trajectory_num_of_points:" << p.trajectory_num_of_points << "\n"
      << "	" << p.privateNamespace_ << "path_subscriber_topic:" << p.path_subscriber_topic << "\n"
      << "	" << p.privateNamespace_ << "path_subscriber_queue_size:" << p.path_subscriber_queue_size << "\n"
      << "	" << p.privateNamespace_ << "trajectory_publisher_topic:" << p.trajectory_publisher_topic << "\n"
      << "	" << p.privateNamespace_ << "trajectory_publisher_queue_size:" << p.trajectory_publisher_queue_size << "\n"
;
    return os;
  }

  /// \brief get the node handle that the interface struct uses internally
  ros::NodeHandle getPrivateNodeHandle() {
      return privateNodeHandle_;
  }

  /// \brief returns the name of the node (works in nodelets, too)
  const std::string& nodeName() const {
      return nodeName_;
  }

  /// \brief returns the name of the node with its namespace (works in nodelets, too)
  const std::string& nodeNameWithNamespace() const {
      return privateNodeHandle_.getNamespace();
  }

  /// \brief logs to the debug output. Works also within nodelets.
  // NOLINTNEXTLINE(readability-function-size)
  template <typename Msg, typename... Msgs>
  inline void logDebug(const Msg& msg, const Msgs&... Msgs_) const {
      ROS_DEBUG_STREAM_NAMED(nodeNameWithNamespace(), rosinterface_handler::asString(msg, Msgs_...));
  }

  /// \brief logs to the debug output. Works also within nodelets. Output is throttled.
  // NOLINTNEXTLINE(readability-function-size)
  template <typename Msg, typename... Msgs>
  inline void logInfo(const Msg& msg, const Msgs&... Msgs_) const {
      ROS_INFO_STREAM_THROTTLE_NAMED(5, nodeNameWithNamespace(), rosinterface_handler::asString(msg, Msgs_...));
  }

  /// \brief logs to the debug output. Works also within nodelets. Output is throttled.
  // NOLINTNEXTLINE(readability-function-size)
  template <typename Msg, typename... Msgs>
  inline void logWarn(const Msg& msg, const Msgs&... Msgs_) const {
      ROS_WARN_STREAM_THROTTLE_NAMED(5, nodeNameWithNamespace(), rosinterface_handler::asString(msg, Msgs_...));
  }

  /// \brief logs to the error output. Works also within nodelets. Output is throttled.
  // NOLINTNEXTLINE(readability-function-size)
  template <typename Msg, typename... Msgs>
  inline void logError(const Msg& msg, const Msgs&... Msgs_) const {
      ROS_ERROR_STREAM_THROTTLE_NAMED(5, nodeNameWithNamespace(), rosinterface_handler::asString(msg, Msgs_...));
  }

  /// \brief logs to the error output. Works also within nodelets. Not throttled! Dont call this in loops!
  // NOLINTNEXTLINE(readability-function-size)
  template <typename Msg, typename... Msgs>
  inline void logErrorDirect(const Msg& msg, const Msgs&... Msgs_) const {
      ROS_ERROR_STREAM_NAMED(nodeNameWithNamespace(), rosinterface_handler::asString(msg, Msgs_...));
  }

  /// \brief logs subscribed and advertised topics to the command line. Works also within nodelets.
  // NOLINTNEXTLINE(readability-function-size)
  void showNodeInfo() const {
      std::string message = "Node '" + nodeName() + "' from package 'kal_trajectory_planner_ros_tool', type 'TrajectoryPlanner'"
                                                    " in namespace '" + publicNamespace_ + "'.\nSubscribed to: [";
      message +=  path_subscriber->getTopic();
      message += "]\nAdvertising: [";
      message +=  trajectory_publisher.getTopic();
      message += ']';
      logInfo(message);
  }

private:
  const std::string globalNamespace_;
  const std::string publicNamespace_;
  const std::string privateNamespace_;
  const std::string nodeName_;
  ros::NodeHandle privateNodeHandle_;

public:
  std::string verbosity; /*!< Sets the verbosity for this node */
  static constexpr auto verbosity_debug = "debug"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_info = "info"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_warning = "warning"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_error = "error"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_fatal = "fatal"; /*!< Constant for enum verbosity */
  std::string map_frame; /*!< TF frame of the map */
  double timer_rate; /*!< Trajectory publisher frequency [Hz] */
  std::string vehicle_frame; /*!< TF frame of the vehicle */
  double desired_speed; /*!< Desired speed [m/s] */
  int polynomial_degree; /*!< The degree of the polynomial used to estimate the trajectory */
  double trajectory_length; /*!< Minimum length of the trajectory [m] */
  int trajectory_num_of_points; /*!< The number of points the published trajectory will have */
  std::string path_subscriber_topic; /*!< Topic for Path subscriber */
  int path_subscriber_queue_size; /*!< Queue size for Path subscriber */
  std::string trajectory_publisher_topic; /*!< Topic for Trajectory publisher */
  int trajectory_publisher_queue_size; /*!< Queue size for Trajectory publisher */
  ros::Publisher trajectory_publisher; /*!< Trajectory publisher */
  SubscriberPtr<nav_msgs::Path> path_subscriber; /*!< Path subscriber */

private:
  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << nodeName_ << "]\nThe following parameters do not have default values and need to be specified:\n"
      << "	" << privateNamespace_ << "map_frame" << " (std::string) \n"
      << "	" << privateNamespace_ << "timer_rate" << " (double) \n"
      << "	" << privateNamespace_ << "vehicle_frame" << " (std::string) \n"
      << "	" << privateNamespace_ << "desired_speed" << " (double) \n"
      << "	" << privateNamespace_ << "polynomial_degree" << " (int) \n"
      << "	" << privateNamespace_ << "trajectory_length" << " (double) \n"
      << "	" << privateNamespace_ << "trajectory_num_of_points" << " (int) \n"
      << "	" << privateNamespace_ << "path_subscriber_topic" << " (std::string) \n"
      << "	" << privateNamespace_ << "trajectory_publisher_topic" << " (std::string) \n"
    );
  }
};
} // namespace kal_trajectory_planner_ros_tool
