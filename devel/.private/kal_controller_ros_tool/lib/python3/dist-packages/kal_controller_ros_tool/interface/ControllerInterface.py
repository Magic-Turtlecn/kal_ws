# *********************************************************
#
# File autogenerated for the kal_controller_ros_tool package
# by the rosinterface_handler package.
# Please do not edit.
#
# *********************************************************
import rospy
import ackermann_msgs.msg
import nav_msgs.msg
import geometry_msgs.msg
import std_msgs.msg
import visualization_msgs.msg

inf = float('inf')
param_description = [{'name': 'verbosity', 'type': 'std::string', 'default': 'info', 'level': 0, 'edit_method': 'verbosity', 'description': 'Sets the verbosity for this node', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': True, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'verbosity_debug', 'type': 'std::string', 'default': 'debug', 'level': 0, 'edit_method': '""', 'description': 'Constant for enum verbosity', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': True, 'global_scope': False, 'pytype': 'str'}, {'name': 'verbosity_info', 'type': 'std::string', 'default': 'info', 'level': 0, 'edit_method': '""', 'description': 'Constant for enum verbosity', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': True, 'global_scope': False, 'pytype': 'str'}, {'name': 'verbosity_warning', 'type': 'std::string', 'default': 'warning', 'level': 0, 'edit_method': '""', 'description': 'Constant for enum verbosity', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': True, 'global_scope': False, 'pytype': 'str'}, {'name': 'verbosity_error', 'type': 'std::string', 'default': 'error', 'level': 0, 'edit_method': '""', 'description': 'Constant for enum verbosity', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': True, 'global_scope': False, 'pytype': 'str'}, {'name': 'verbosity_fatal', 'type': 'std::string', 'default': 'fatal', 'level': 0, 'edit_method': '""', 'description': 'Constant for enum verbosity', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': True, 'global_scope': False, 'pytype': 'str'}, {'name': 'control_loop_rate', 'type': 'double', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Controller loop rate [Hz]', 'min': 1.0, 'max': 200.0, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'double'}, {'name': 'map_frame', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'TF frame_id of map', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'vehicle_frame', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'TF frame_id of vehicle', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'wheel_base', 'type': 'double', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Wheelbase of the vehicle [m]', 'min': 0, 'max': 3.0, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'double'}, {'name': 'k_angular', 'type': 'double', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Angle weight [-]', 'min': 0, 'max': 10, 'is_vector': False, 'is_map': False, 'configurable': True, 'constant': False, 'global_scope': False, 'pytype': 'double'}, {'name': 'k_distance', 'type': 'double', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Distance weight [-]', 'min': 0, 'max': 10, 'is_vector': False, 'is_map': False, 'configurable': True, 'constant': False, 'global_scope': False, 'pytype': 'double'}, {'name': 'look_ahead_index', 'type': 'int', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Index shift of lookahead point [-]', 'min': 1, 'max': 50, 'is_vector': False, 'is_map': False, 'configurable': True, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'publish_debug_info', 'type': 'bool', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Whether or not to publish debug info', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': True, 'constant': False, 'global_scope': False, 'pytype': 'bool'}, {'name': 'steering_angle_max', 'type': 'double', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'The maximum steering angle [rad]', 'min': 0.0, 'max': 1.0, 'is_vector': False, 'is_map': False, 'configurable': True, 'constant': False, 'global_scope': False, 'pytype': 'double'}, {'name': 'trajectory_age_max', 'type': 'double', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Maximum age of last trajectory before stopping the vehicle [s]', 'min': 0.1, 'max': 5.0, 'is_vector': False, 'is_map': False, 'configurable': True, 'constant': False, 'global_scope': False, 'pytype': 'double'}, {'name': 'min_velocity_threshold', 'type': 'double', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Desired velocity threshold below which the car stops driving [m/s]', 'min': 0.01, 'max': 2, 'is_vector': False, 'is_map': False, 'configurable': True, 'constant': False, 'global_scope': False, 'pytype': 'double'}, {'name': 'trajectory_subscriber_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Trajectory subscriber', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'trajectory_subscriber_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Trajectory subscriber', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'control_command_publisher_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Control command publisher', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'control_command_publisher_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Control command publisher', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'debug_control_command_viz_publisher_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Visualization of control command', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'debug_control_command_viz_publisher_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Visualization of control command', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'debug_closest_point_on_trajectory_publisher_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Debug Info: Closest point on trajectory', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'debug_closest_point_on_trajectory_publisher_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Debug Info: Closest point on trajectory', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'debug_look_ahead_point_publisher_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Debug Info: Look ahead point', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'debug_look_ahead_point_publisher_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Debug Info: Look ahead point', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'debug_angle_path_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Debug Info: Angle of the path', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'debug_angle_path_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Debug Info: Angle of the path', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'debug_curvature_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Debug Info: Curvature of the path', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'debug_curvature_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Debug Info: Curvature of the path', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'debug_error_angle_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Debug Info: Heading error of the vehicle w.r.t. to the trajectory', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'debug_error_angle_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Debug Info: Heading error of the vehicle w.r.t. to the trajectory', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'debug_error_signed_distance_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Debug Info: Error of lateral position of the vehicle w.r.t. the trajectory', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'debug_error_signed_distance_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Debug Info: Error of lateral position of the vehicle w.r.t. the trajectory', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}, {'name': 'debug_yaw_vehicle_topic', 'type': 'std::string', 'default': None, 'level': 0, 'edit_method': '""', 'description': 'Topic for Debug Info: The yaw angle of the vehicle', 'min': None, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'str'}, {'name': 'debug_yaw_vehicle_queue_size', 'type': 'int', 'default': 5, 'level': 0, 'edit_method': '""', 'description': 'Queue size for Debug Info: The yaw angle of the vehicle', 'min': 0, 'max': None, 'is_vector': False, 'is_map': False, 'configurable': False, 'constant': False, 'global_scope': False, 'pytype': 'int'}]
subscriber_description = [{'name': 'trajectory_subscriber', 'type': 'nav_msgs::Path', 'header': ['nav_msgs/Path.h'], 'import': ['nav_msgs.msg'], 'topic_param': 'trajectory_subscriber_topic', 'queue_size_param': 'trajectory_subscriber_queue_size', 'no_delay': True, 'configurable': False, 'description': 'Trajectory subscriber', 'scope': 'private', 'diagnosed': False, 'watch': [], 'min_frequency_param': None, 'max_delay_param': None}]
publisher_description = [{'name': 'control_command_publisher', 'type': 'ackermann_msgs::AckermannDriveStamped', 'header': ['ackermann_msgs/AckermannDriveStamped.h'], 'import': ['ackermann_msgs.msg'], 'topic_param': 'control_command_publisher_topic', 'queue_size_param': 'control_command_publisher_queue_size', 'configurable': False, 'description': 'Control command publisher', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}, {'name': 'debug_control_command_viz_publisher', 'type': 'visualization_msgs::Marker', 'header': ['visualization_msgs/Marker.h'], 'import': ['visualization_msgs.msg'], 'topic_param': 'debug_control_command_viz_publisher_topic', 'queue_size_param': 'debug_control_command_viz_publisher_queue_size', 'configurable': False, 'description': 'Visualization of control command', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}, {'name': 'debug_closest_point_on_trajectory_publisher', 'type': 'geometry_msgs::PointStamped', 'header': ['geometry_msgs/PointStamped.h'], 'import': ['geometry_msgs.msg'], 'topic_param': 'debug_closest_point_on_trajectory_publisher_topic', 'queue_size_param': 'debug_closest_point_on_trajectory_publisher_queue_size', 'configurable': False, 'description': 'Debug Info: Closest point on trajectory', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}, {'name': 'debug_look_ahead_point_publisher', 'type': 'geometry_msgs::PointStamped', 'header': ['geometry_msgs/PointStamped.h'], 'import': ['geometry_msgs.msg'], 'topic_param': 'debug_look_ahead_point_publisher_topic', 'queue_size_param': 'debug_look_ahead_point_publisher_queue_size', 'configurable': False, 'description': 'Debug Info: Look ahead point', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}, {'name': 'debug_angle_path', 'type': 'std_msgs::Float64', 'header': ['std_msgs/Float64.h'], 'import': ['std_msgs.msg'], 'topic_param': 'debug_angle_path_topic', 'queue_size_param': 'debug_angle_path_queue_size', 'configurable': False, 'description': 'Debug Info: Angle of the path', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}, {'name': 'debug_curvature', 'type': 'std_msgs::Float64', 'header': ['std_msgs/Float64.h'], 'import': ['std_msgs.msg'], 'topic_param': 'debug_curvature_topic', 'queue_size_param': 'debug_curvature_queue_size', 'configurable': False, 'description': 'Debug Info: Curvature of the path', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}, {'name': 'debug_error_angle', 'type': 'std_msgs::Float64', 'header': ['std_msgs/Float64.h'], 'import': ['std_msgs.msg'], 'topic_param': 'debug_error_angle_topic', 'queue_size_param': 'debug_error_angle_queue_size', 'configurable': False, 'description': 'Debug Info: Heading error of the vehicle w.r.t. to the trajectory', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}, {'name': 'debug_error_signed_distance', 'type': 'std_msgs::Float64', 'header': ['std_msgs/Float64.h'], 'import': ['std_msgs.msg'], 'topic_param': 'debug_error_signed_distance_topic', 'queue_size_param': 'debug_error_signed_distance_queue_size', 'configurable': False, 'description': 'Debug Info: Error of lateral position of the vehicle w.r.t. the trajectory', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}, {'name': 'debug_yaw_vehicle', 'type': 'std_msgs::Float64', 'header': ['std_msgs/Float64.h'], 'import': ['std_msgs.msg'], 'topic_param': 'debug_yaw_vehicle_topic', 'queue_size_param': 'debug_yaw_vehicle_queue_size', 'configurable': False, 'description': 'Debug Info: The yaw angle of the vehicle', 'scope': 'private', 'diagnosed': False, 'min_frequency_param': None, 'max_delay_param': None}]
verbosity_param = "verbosity"
tf_config = None
with_diagnostics = False
simplified_diagnostics = False

if subscriber_description:
    # only import if necessary
    import message_filters
if verbosity_param:
    import logging
if tf_config:
    import tf2_ros


defaults = {}

for param in param_description:
    defaults[param['name']] = param['default']
for subscriber in subscriber_description:
    defaults[subscriber['name']] = None
for publisher in publisher_description:
    defaults[publisher['name']] = None

class _SimplifiedNodeStatus:
    def __init__(self, updater):
        self._updater = updater
        self._updater.add("status", self.get_status)
        self._s = diagnostic_msgs.msg.DiagnosticStatus.STALE
        self._msg = "Initializing"
        self._timer = rospy.Timer(rospy.Duration(1.01), lambda event: self._updater.update(), oneshot=False)

    def set(self, diagnostic_status, message):
        """
        Update the status of this node. To be called via the interface class as
        Interface.node_status.set(DiagnosticStatus.OK, "Everything ok")
        """
        new_status = diagnostic_status != self._s and self._msg != message
        self._s = diagnostic_status
        self._msg = message
        if new_status and self._s == diagnostic_msgs.msg.DiagnosticStatus.ERROR:
            self._updater.force_update()

    def get_status(self, status_wrapper):
        status_wrapper.summary(self._s, self._msg)


class ControllerInterface(dict):
    def __init__(self):
        super(self.__class__, self).__init__(defaults)
        self.from_param_server()
        if tf_config:
            self._init_tf()
        if with_diagnostics:
            from diagnostic_updater import Updater
            self["updater"] = Updater()
            self["updater"].setHardwareID("none")
            if simplified_diagnostics:
                self["node_status"] = _SimplifiedNodeStatus(self["updater"])

    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__

    def from_param_server(self):
        """
        Reads and initializes parameters, subscribers and publishers with values from parameter server.
        Called automatically at initialization.
        """
        for k, v in self.items():
            config = next((item for item in param_description if item["name"] == k), None)
            if not config:
                continue
            if config['constant']:
                self.test_const_param(k)
                continue
            self[k] = self.get_param(k, config)

        for subscriber in subscriber_description:
            name = subscriber['name']
            topic = self._get_topic(subscriber['scope'], self[subscriber['topic_param']])

            # rescue the callbacks if existing
            if name in self and self[name]:
                callbacks = self[name].callbacks
                self[name].callbacks = {}
            else:
                callbacks = {}
            self[name] = message_filters.Subscriber(topic, self.get_type(subscriber),
                                                    queue_size=self[subscriber['queue_size_param']],
                                                    tcp_nodelay=subscriber['no_delay'])
            self[name].callbacks = callbacks
        for publisher in publisher_description:
            name = publisher['name']
            topic = self._get_topic(publisher['scope'], self[publisher['topic_param']])
            self[name] = rospy.Publisher(topic, self.get_type(publisher),
                                         queue_size=self[publisher['queue_size_param']])
        if verbosity_param:
            logging.getLogger('rosout').setLevel(self._map_verbosity(self[verbosity_param]))

    def to_param_server(self):
        """
        Sets parameters with current values on the parameter server.
        """
        for param_name, param_value in self.items():
            config = next((item for item in param_description if item["name"] == param_name), None)
            if config and not config['constant']:
                full_name = "/" + param_name if config['global_scope'] else "~" + param_name
                if config['type'] == 'int64_t':
                    rospy.set_param(full_name, str(param_value)+"L")
                else:
                    rospy.set_param(full_name, param_value)

    def from_config(self, config):
        """
        Reads parameter from a dynamic_reconfigure config file.
        Should be called in the callback of dynamic_reconfigure.
        :param config: config object from dynamic reconfigure
        """
        if verbosity_param and verbosity_param in config and config[verbosity_param] != self[verbosity_param]:
            logging.getLogger('rosout').setLevel(self._map_verbosity(config[verbosity_param]))
            rospy.logdebug("Verbosity set to " + config[verbosity_param])
        for subscriber in subscriber_description:
            topic_param = subscriber['topic_param']
            if not topic_param in config:
                continue
            name = subscriber['name']
            queue_param = subscriber['queue_size_param']
            if config[topic_param] != self[topic_param] or config[queue_param] != self[queue_param]:
                callbacks = self[name].callbacks
                self[name].callbacks = {}
                topic = self._get_topic(subscriber['scope'], config[topic_param])
                self[name] = message_filters.Subscriber(topic, self.get_type(subscriber),
                                                        queue_size=config[queue_param],
                                                        tcp_nodelay=subscriber['no_delay'])
                self[name].callbacks = callbacks
        for publisher in publisher_description:
            topic_param = publisher['topic_param']
            if not topic_param in config:
                continue
            name = publisher['name']
            queue_param = publisher['queue_size_param']
            topic = self._get_topic(publisher['scope'], config[topic_param])
            if config[topic_param] != self[topic_param] or config[queue_param] != self[queue_param]:
                self[name] = rospy.Publisher(topic, self.get_type(publisher), queue_size=config[queue_param])
        for k, v in config.items():
            # handle reserved name groups
            if k == "groups":
                continue
            if not k in self:
                raise TypeError("Element {} of config is not part of parameters.".format(k))
            self[k] = v

    def _init_tf(self):
            listener = tf_config["listener_name"]
            buffer = tf_config["buffer_name"]
            broadcaster = tf_config["broadcaster_name"]
            if buffer:
                self[buffer] = tf2_ros.Buffer()
            if listener:
                self[listener] = tf2_ros.TransformListener(self[buffer])
            if broadcaster:
                self[broadcaster] = tf2_ros.TransformBroadcaster

    @staticmethod
    def test_const_param(param_name):
        if rospy.has_param("~" + param_name):
            rospy.logwarn(
                "Parameter {} was set on the parameter server even though it was defined to be constant.".format(
                    param_name))

    @staticmethod
    def get_param(param_name, config):
        def get_type(type_string):
            if type_string == 'std::string':
                return str
            elif type_string == 'int':
                return int
            elif type_string == 'bool':
                return bool
            elif type_string == 'float' or type_string == 'double':
                return float
            elif type_string == 'int64_t':
                return int
            else:
                raise ValueError()

        full_name = "/" + param_name if config['global_scope'] else "~" + param_name
        try:
            val = rospy.get_param(full_name)
        except KeyError:
            if config['default'] is None:
                raise KeyError("Parameter {} is neither set on the parameter server nor "
                               "has it a default value".format(param_description))
            rospy.loginfo("Parameter {} is not yet set. Setting default value".format(param_name))
            rospy.set_param(full_name, config['default'])
            val = config['default']

        # test whether type is correct
        try:
            if config['is_vector']:
                val = list(val)
                config_type = config['type']
                val_type = get_type(config_type[config_type.find("<")+1:config_type.find(">")])
                val = [ val_type(v) for v in val ]
            elif config['is_map']:
                val = dict(val)
                config_type = config['type']
                key_type = get_type(config_type[config_type.find("<")+1:config_type.find(",")])
                val_type = get_type(config_type[config_type.find(",")+1:config_type.find(">")])
                val = { key_type(key): val_type(v) for key, v in val.items() }
            elif config['type'] == 'int64_t' and type(val) is str:
                val = val.replace("L","",1)
                val = int(val)
            else:
                val = get_type(config['type'])(val)
        except ValueError:
            rospy.logerr(
                "Parameter {} is set, but has a different type ({} instead of {}). Using default value instead.".format(
                    param_name, type(val), config['type']))
            val = config['default']
        # test bounds
        if config['min'] is not None:
            if config['is_vector']:
                if min(val) < config['min']:
                    rospy.logwarn(
                        "Some values in {} for {} are smaller than minimal allowed value. "
                        "Correcting them to min={}".format(val, param_name, config['min']))
                    val = [ v if v > config['min'] else config['min'] for v in val ]
            elif config['is_map']:
                if min(val.values()) < config['min']:
                    rospy.logwarn(
                        "Some values in {} for {} are smaller than minimal allowed value. "
                        "Correcting them to min={}".format(val, param_name, config['min']))
                    val = { k: (v if v > config['min'] else config['min']) for k, v in val.items() }
            elif val < config['min']:
                rospy.logwarn(
                    "Value of {} for {} is smaller than minimal allowed value. "
                    "Correcting value to min={}".format(val, param_name, config['min']))
                val = config['min']

        if config['max'] is not None:
            if config['is_vector']:
                if max(val) > config['max']:
                    rospy.logwarn(
                        "Some values in {} for {} are greater than maximal allowed value. "
                        "Correcting them to max={}".format(val, param_name, config['max']))
                    val = [ v if v < config['max'] else config['max'] for v in val ]
            elif config['is_map']:
                if max(val.values()) > config['max']:
                    rospy.logwarn(
                        "Some values in {} for {} are greater than maximal allowed value. "
                        "Correcting them to max={}".format(val, param_name, config['max']))
                    val = { k: (v if v < config['max'] else config['max']) for k, v in val.items() }
            elif val > config['max']:
                rospy.logwarn(
                    "Value of {} for {} is greater than maximal allowed value. "
                    "Correcting value to max={}".format(val, param_name, config['max']))
                val = config['max']
        return val

    @staticmethod
    def get_type(config):
        for import_cmd in config['import']:
            try:
                return eval(import_cmd + '.' + config['type'].split('::')[-1])
            except:
                pass


    @staticmethod
    def _get_topic(scope, topic):
        if not topic.startswith('/') and scope != 'public':
            return "/" + topic if scope == 'global' else "~" + topic
        return topic

    @staticmethod
    def _map_verbosity(verbosity):
        return {
              'DEBUG':    logging.DEBUG,
              'INFO':     logging.INFO,
              'WARN':     logging.WARN,
              'WARNING':  logging.WARN,
              'ERROR':    logging.ERROR,
              'FATAL':    logging.FATAL,
              }[verbosity.upper()]
